(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[810],{5268:(e,t,n)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/post/[slug]",function(){return n(7410)}])},4615:(e,t,n)=>{"use strict";n.d(t,{Y:()=>o});let o=[{slug:"react-hooks-dependency-comparison",name:"How React Decides When to Rerun Hooks: The is Function Explained",description:"React doesn’t just use === to compare hook dependencies — it uses a custom polyfill for Object.is. This subtle but important function ensures correct behavior for tricky cases like +0 vs -0 and NaN.\n\nIn this post, I dive into how React internally compares dependencies using this is() function, and why your hooks (like useEffect or useMemo) won’t rerun unless the reference of an object, array, or function actually changes — even if the content does.\n\nIf you’ve ever wondered why your effect didn’t trigger after updating an object, this will make it crystal clear."}]},7410:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>c});var o=n(4848),s=n(6715),r=n(6540),i=n(509),a=n(4615);let c=()=>{let e=(0,s.useRouter)(),{slug:t}=e.query,[n,c]=(0,r.useState)("");(0,r.useEffect)(()=>{t&&fetch("".concat(e.basePath,"/post/").concat(t,".md")).then(e=>e.text()).then(c)},[t]);let u=a.Y.find(e=>e.slug===t);return u?(0,o.jsxs)("div",{style:{padding:32,background:"#fff",maxWidth:800,overflow:"auto",margin:"32px auto",boxShadow:"0 2px 8px rgba(0,0,0,0.06)"},children:[(0,o.jsx)("h1",{children:u.name}),(0,o.jsx)(i.oz,{children:n})]}):(0,o.jsx)("div",{children:"Post not found"})}}},e=>{var t=t=>e(e.s=t);e.O(0,[509,636,593,792],()=>t(5268)),_N_E=e.O()}]);